### 1879.Minimum-XOR-Sum-of-Two-Arrays
本题属于带权二分图匹配问题，标准的解法是KM算法。这里只用状态压缩的搜索算法解决。思路和```1066.Campus bike II```差不多。


#### 解法1
我们用压缩状态state来代表nums1里有哪些元素已经匹配。比如01101表示nums1里面的第0,2,3号元素已经匹配。dp[state]表示当前该状态下能够得到的最优代价。注意到，dp[state]并不区分已经匹配的nums1元素究竟分别是和哪些nums2元素配对的。相比于暴力搜索我们需要穷举所有的配对细节，这样的“模糊处理”是节省时间和空间的关键。

我们依次遍历每个nums2的元素，考察nums2[j]加入后，能够如何更新dp[state]。举个例子，当考察j=2时，dp[state]表示使用了nums2的前3个（包括j=2）元素之后state的最优代价。那么state里面到底哪个nums1元素是与j相匹配呢？我们只要遍历state里面的bit 1即可，那些bit对应了nums1的元素i。于是就有转移方程```dp[state] = dp[state-(1<<i)] + (nums1[i]^nums2[j])```.

最终的答案就是当nums1的所有元素都被匹配时的最优代价，即```dp[(1<<m)-1]```.
