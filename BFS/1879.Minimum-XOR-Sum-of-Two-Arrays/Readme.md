### 1879.Minimum-XOR-Sum-of-Two-Arrays
本题属于带权二分图匹配问题，标准的解法是KM算法。这里只用状态压缩的搜索算法解决。思路和```1066.Campus bike II```差不多。


#### 解法1
我们用压缩状态state来代表nums1里有哪些元素已经匹配。比如01101表示nums1里面的第0,2,3号元素已经匹配。dp[state]表示当前该状态下能够得到的最优代价。注意到，我们并不区分已经匹配的nums1元素究竟具体是和那些nums2元素配对的。

我们依次遍历每个nums2的元素，考察nums2的新元素加入后，能够如何更新dp[state]。举个例子，当考察j=2时，dp[state]表示使用了nums2的前3个（包括j=2）元素之后的最优代价。那么state里面到底哪个nums1元素是与j相匹配呢？我们遍历state里面的bit 1即可，对应了nums1的元素i。于是就有转移方程```dp[state] = dp[state-(1<<i)] + (nums1[i]^nums2[j])```.

最终的答案就是当nums1的所有元素都被匹配时的最优代价，即```dp[(1<<m)-1]```.
