### 1665.Minimum-Initial-Energy-to-Finish-Tasks

我们令每个任务的actual cost属性为a，mimimum energy to start属性为b。我们先考虑：最优解T必然大于等于所有任务的a属性之和。所以即使任务次序任意打乱，总能保证做每个任务时都能有足够的energy被消耗。但是属性b要求某些任务必须在存留能量很高的时候才能被启动。所以一个比较自然的贪心想法就是将所有的任务按照属性b排序，优先做属性b较大的任务，这样可以最大程度保证它能启动。

举个例子，如果按照属性b的次序排序样例2：[1,3],[2,4],[8,9],[10,11],[10,12]。我们从最终状态能量为0开始，逆推最初所需要的能量。我们可以写出这样的计算式：
```cpp
int ret = 0;
for (int i=0; i<n; i++)
  ret = max(ret+tasks[i][0], tasks[i][1])``` //前者是考虑完成该任务需要消耗的能量，后者是考虑启动该任务前的能量下限
```
但结果发现结果是33，并非是最优的32. 那么32是怎么得到的呢？实际的最优操作顺序是（从后往前）：[8,9],[10,11],[10,12],[2,4],[1,3]

我们思考一下为什么需要把[1,3]的属性a和b都很小，但为什么会作为最先启动的任务？我们很容易发现它的b-a其实是所有任务里最大的。这是不是暗示了我们需要把任务按照b-a来排序呢？我们来实验一下：假设任务1(a1,b1)和任务2(a2,b2)，有b2-a2>b1-a1，我们来看一下分别用两种策略所得到的倒推最小初始能量的效果区别：
1. 倒推时先1后2之后的初始能量：T1 = max(max(a1, b1) + a2, b2) = max(max(a1+a2, b1+a2), b2) 
2. 倒推时先2后1之后的初始能量：T2 = max(max(a2, b2) + a1, b1) = max(max(a2+a1, b2+a1), b1)

因为b2-a2>b1-a1，所以b1+a2<b2+a1，所以一定有 x1=max(a1+a2, b1+a2) < x2=max(a2+a1, b2+a1)。 于是上面两式继续变化为
```
T1 = max(x1, b2)
T2 = max(x2, b1)
x1 < x2
```
如果b2 < b1，那么显然T1 < T2. 如果b2 > b1，我们考察 x2 = max(a2+a1, b2+a1) >= b2+a1 > b1+a1 > b1，所以 T2 = max(x2, b1) = x2 < x1 < T1。

总之无论如何都有T1<T2，方案1更优。所以我们有结论：如果两个任务相邻，我们肯定会把b-a较小的放在倒推序列的前面。把这个结项想象成冒泡排序的规则，通过它我们就可以得到一个排序的序列，使得倒推得到的初始能量最小。
