### 3609.Minimum-Moves-to-Reach-Target-in-Grid

注意到sx,sy和tx,ty都是正数，所有的操作只能单向地使得数值变大。

我们思考(sx,sy)变成(tx,ty)的过程中的最后一步，即从(a,b)->(tx,ty）。因为增量`m=max(a,b)`很大，所以无论是第一个分量还是第二个分量，加上m之后都会大于另一个。所以我们从tx和ty的大小比较中就可以知道，最后一次操作是作用在了哪个分量上面。这里我们分情况讨论.

如果tx>ty，那么显然最后一次操作是加在了第一个分量上面。即`tx=a+max(a,b), ty=b`。继续分类讨论
1. 如果max(a,b)=a，则有tx=2a，继而得到`a=tx/2, b=ty`，这等价于`tx>=2*ty`. 也就是说，在此情况下，(tx,ty)的前一步必然是(tx/2,ty)。于是我们发现如果tx不能被2整除，那么前一步是不存在的；反之我们可以递归处理成`minMoves(sx,sy,tx/2,ty)+1`即可.

2. 如果max(a,b)=a，则有tx=a+b，继而得到`a=tx-ty, b=ty`这等价于`tx<2*ty`. 在此情况下，(tx,ty)的前一步必然是(tx-ty,ty)。于是我们可以递归处理成`minMoves(sx,sy,tx-ty,ty)+1`即可.

如果tx<ty，考虑到两个分量在形式上没有区别，我们可以转化为上面的分析：等价于求解`minMove(sy,sx,ty,tx)`.

如果tx==ty，我们记作(a,b)->(x,x)。继续分类讨论：
1. 如果操作是作用于第一个分量上面，`x=a+max(a,b), x=b`，必然有a==0. 继而b=x，原题转化为`minMoves(sx,sy,0,x)+1`

2. 如果操作是作用于第二个分量上面，`x=a, x=b+max(a,b)`，必然有b==0. 继而a=x，原题转化为`minMoves(sx,sy,x,0)+1`

最终的边界条件就是`sx==tx && sy==ty`时，返回0. 如果tx和ty的任意分量小于sx和sy，那么返回-1.
