### 2910.Minimum-Number-of-Groups-to-Create-a-Valid-Assignment

我们首先将所有元素的频率收集起来放入一个数组arr。本题就是将arr里的每个元素都做拆分，要求最多只能拆分出两种相邻的数字（记做k和k+1）。求最少能拆分出多少个数字来。

本题的一个坑就是二分搜索是不成立的。这是说拆分的越多就越容易，这里没有单调性。比如说，[10,20]可以拆分出k=10, 即[10,10,10]；但不能拆分出k=9；但是又可以拆分出k=5，即[5,5,5,5,5,5]. 

本题的解法其实就是暴力尝试。假设arr的长度是n，出现最小的频次是m，那么我们就从`k=m,m-1,...,1`逐个尝试，找到最大的k使得所有arr的元素都能成功拆分成若干个k或k+1的和。这样的时间复杂度看上去是0(mn). 事实上mn有制约关系，如果nums的种类各不相同，那么m就是1，n就是1e5；如果nums的种类完全相同，那么m就是1e5，n就是1. 事实上，o(mn)就是1e5数量级。

接下来我们考虑，如果给定了k，如何判定某个arr的元素x能成功拆封成若干个k或k+1之和？我们将x尽量拆分出k来，得到`q = x/k`个group，以及余数`r = x%k`. 如果`r<=q`，意味着我们可以将这些余数拆散到每个group去，而那些group的值就是`k+1`了依然符合要求. 这就是判据。

最终当我们找到最大的k，使得所有arr的x都能成立时，我们用`ceil(x*1.0/(k+1))`即可计算出总共分成的group的数目。
