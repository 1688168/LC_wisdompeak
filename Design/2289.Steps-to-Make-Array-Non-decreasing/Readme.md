### 2289.Steps-to-Make-Array-Non-decreasing

本题的关键点是，如果某个位置i满足条件nums[i-1]>nums[i]需要被删除，那么导致的后果就是，在下一个回合，如果i后面的那个元素j（不见得是i+1，有可能i+1在这个回合已经被删除了）满足```nums[i-1]>nums[j]```的话，那么j会在“下一个回合”删除。那么如果确保j不是在这个回合就已经被删除了的呢？我们只需要倒序遍历。

举个例子，如下图，如果元素j被判定在本回合不会被删除，继续往前遍历，且i+1,i+2,...,j-1这些元素也在本回合删除，那么在考察元素i的时候就有next(i) = j，那么我们就可以安心地把j作为“下一个回合”待删除的对象。
```
i-1, i, i+1, i+2, ..., j-1, j
     X    X   X         X   O
```
以上的关键就是如何高效地维护next和prev，即如何快速某个元素后面一个/前面一个尚未被删除的元素（或者说idx）。

#### 解法1：暴力模拟
和```LRU Cache```和```LFU Cache```一样，将链表和关于“元素->链表地址”的Hash结合起来用，是一个大杀器，可以保证在o(1)时间内的查找、删除。本题中，我们定义
```cpp
list<int> List;
unordered_map<int,list<int>::iterator>idx2iter;
```   
链表List里面初始节点是一串编号{0,1,2,...,n-1}，idx2iter则代表着链表每个节点的指针。

我们从后往前遍历，如果某个idx满足被删除的条件，令iter表示该idx的指针，那么就意味着next(iter)直接就是下一个节点的指针（无论两者之间已经删除了多少结果）。我们将```*next(iter)```这个后续编号放入一个candidates集合里，此时可以安心的将iter本身删除，而List的数据结构会自动将前后节点“接合”在一起。

我们倒序走完一遍后，剩下的candidates里面的编号，还需要再考察一遍是否满足```nums[*prev(idx2iter[idx])] > nums[idx]```，将那些符合条件的再进行下一遍的倒序遍历。

显然，这种结构就是层级遍历的BFS。答案就是看走了几个回合。

#### 解法2：高效模拟
在解法1中我们考察的是点，所以需要依靠List和Hash来额外维护next和prev。一个更好的解法是考察一对pair。同时用removed数组来标记节点的删除，而不用List。

我们在层级遍历BFS的过程中，加入的元素记做{l,r}表示此时一对相邻的编号且满足nums[l]>nums[r]. 那么在处理这对pair的时候，我们会标记removed[r]=1，同时根据之前的思路，我们要找到r此时的右邻元素编号next[r]。但是这里有一个问题，next[r]可能恰好在这个回合里面被删除了（因为我们是倒序遍历的），且此时我们必须找到再右邻的元素（不能放弃）。显然我们需要不断跳转来寻找：
```cpp
r2 = r;
while (r2!=n && removed[r2])
  r2 = next[r2];
```
递归结束后所找到的r2肯定是当前回合未被删除的，如果满足大小关系，那么[l, r2]就是下一个回合需要考察的pair。记得别忘了更新```next[r] = r2```，这样能加快今后的跳转效率。

此外还需要特别说明的是，虽然在这个回合里面，我们已经判定[l,r2]是下一个回合需要考察的pair，但注意到编号l的元素在本回合中尚未被遍历到（因为它是r左边的元素）。等到了下一个回合时，有可能我们发现l已经被删除了，那么此时的这个pair就作废了，跳过即可。但这没有关系，不意味着我们漏掉了r2，因为r2可能还会因为和其他的l2配对在一起。

