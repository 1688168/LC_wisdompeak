### 2439.Minimize-Maximum-of-Array

本题的大体思路就是，如果有一个数字特别大，那么我们希望它能与之前的数字们一起“抹匀”，来尽量减少最大值。由于更靠前的数字，只能与更少数量的伙伴一起“抹匀”，所以最终呈现出来的最优解形态，应该是piece-wise constant的递减数列。这个数列的第一个元素的大小，就是最终答案。

那么这个数字最小是什么呢？并不太容易直接求出来。但是如果我们猜测一个，是容易判断它是否成立的。

我们首先猜测最终答案是x。明显，这个x必然不会小于nums[0]，因为nums[0]没有机会向前分摊数值。如果x>nums[0]，那么这意味着后面的元素有机会向nums[0]分摊一些数值，我们记做“缓冲值”：`buff = x-nums[0]`. 

接下来我们看nums[1]。如果`nums[1]>x`，那么不得不让它往前分摊数值，最多能够分摊多少呢？显然就是buff。于是如果`buff> nums[1]-x`，那么就OK，同时`buff-=nums[1]-x`；否则就直接返回失败。反之，如果`nums[1]<x`，同样意味着后面的元素有机会往前分摊数值，这部分分摊可以均匀承担在nums[0]与nums[1]上，所以`buff+= x-nums[1]`。

由此可见，我们需要做的就是不停的比较x与nums[i]，根据孰大孰小和增加或者减少buffer。当buffer降为0以下的时候，说明无法实现前面若干个元素“抹匀”成x（或更小），返回失败。否则返回成功。

通过二分搜值的讨论，我们可以很容易求出满足条件的最小值。

注意本题一定有解（什么都不做就可以返回数组最大值），因此二分搜值的收链解就是最优解。
