### 792.Number-of-Matching-Subsequences

传统的方法，利用刷指针挨个比较s和word，那么时间复杂度就是o(ST)，其中S是s的长度，T是words的总长度。本题的考点在于s的长度很大时，时间复杂度如何优化。

我们可以提前预处理s，将每个字符出现的位置分别归类，即pos[ch]包含了s里的字符ch所在的位置。这样我们在查看word[0]='a'的时候，直接从pos['a']里面找最早的位置i。再查看word[1]='b'的时候，又从pos['b']里面找第一个大于等于i的位置j。再查看word[1]='c'的时候，从pos['c']里面找第一个大于等于j的位置k。依次类推。如果遇到某个word的字符ch，但是pos[ch]里面没有大于等于k的位置，那么这个word就不是s的子序列了。
