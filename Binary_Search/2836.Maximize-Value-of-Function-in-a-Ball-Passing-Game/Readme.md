### 2836.Maximize-Value-of-Function-in-a-Ball-Passing-Game

如果不看数据范围，一个比较容易想到的方法就是动态规划。为什么呢？我们取一段序列prev[i],i,recevier[i]进行观察。这三个位置在跳转顺序上是从前往后连续的。

假设想求以节点i为结尾的、长度为k的序列的最大值，那么我们必然想知道以节点prev[i]为结尾的、长度为k-1的序列的最大值，这样在其基础上加上i就是期望的value. 可见，对于任何一个节点，我们不仅要考虑它为k-size序列终点时的最大value，也要考虑它作为k-1 size序列终点的最大value，以此类推。这样就有转移方程`dp[i][d] = max{dp[prev[i]] + i}`，其中dp[i][d]表示以i为结尾的、长度为d的序列的value最大值，其中`d=1,2,...,k`。

但在此题中，d的范围是`1e10`，这样的二维数组无法存下。此时有一个技巧叫做binary lifting，第二个维度只需要存储对数个信息。

具体地，我们令dp[i][j]表示从i开始走2^j步所能得到的最大value。同时辅助pos[i][j]表示从i开始走2^j步所到达的位置。我们用二分来进行状态转移，即找到中点2^(j-1)步后的位置pos[i][j-1]，然后从这里再走2^(j-1)步，故转移方程就有
```cpp
pos[i][j] = pos[pos[i][j-1]][j-1];
dp[i][j] = dp[i][j-1] + dp[pos[i][j-1]][j-1];
```

因为我们最多走1e10步，相当于2^34，状态变量里的第二个维度最多34. 我们将j从1到34从小到大进行遍历，根据上面的式子即可顺利填充所有的dp[i][j]和pos[i][j].

最终我们需要考察所有的位置i，看它走k步所能得到的最大value，然后全局取最大值。注意，如果k不是2的次幂的话，我们就没有现成的dp[i][j]作为答案。但是没关系，我们将k进行二进制分解为`2^j0+2^j1+2^j2+...`后，相当于从i开始先走2^j0步，再走2^j1步，再走2^j2步... 于是我们只需要依次找到这些中继点i,i1,i2,...，将每一段跨度的value累加起来即可，即`sum[i] = dp[i][j0] + dp[i1][j1] + dp[i2][j2] + ... `. 其中`i1=pos[i][j1]`，其他的跳转点以此类推。
