### 1392.Longest-Happy-Prefix

这道题所求的东西其实就是KMP算法中的一个重要的步骤，称为求后缀数组。我们先来回顾一下后缀数组在KMP中的应用。

我们令长字符串为s，目标字符串为t。后缀数组suffix[j]指的是：以其t[j]为尾字符的最长的后缀子串，恰好同时满足它是t的前缀。也就是说，如果suffix[j-1]==k的话，那么t[0:k-1]==t[j-k:j-1]。注意，这里的k可以是零。

下面举个例子。我们在如下的位置尝试将t[0]与s[i-4]对齐进行匹配。结果发现最多只能匹配到t[4]==s[i]，当查到t[5]!=s[i+1]时匹配失败。
```
          i
s:bacbababaabcbab
      |||||
t:    abababca
      012345
```    
这时候是否意味着我们只能将t[0]重新与s[i-3]对齐然后再匹配呢？其实不用。我们如果查到suffix[4]=3的话（结合上面的定义，这个前缀与后缀的共同子串就是"aba"），我们知道s[i-2:i]==t[0:2]，于是下一步我们可以直接将s[i-2]和t[0]对齐，而且这个对齐必定能保证3个字符的匹配，意味着下一次我们只要查看s[i+1]是否和t[3]相等就行了。（见下图）
```
          i
s:bacbababaabcbab
        |||
t:      abababca
        012345
```    
总结一下，我们从s[i+1]!=t[j+1]时的匹配失败，可以跳转的下一步是检查s[i+1]是否能和t[suffix[j]]匹配，而不必重头检查s的下一个字符与t[0]开始匹配。这中间优化的一步就是充分利用了后缀数组的作用：已知当前s[i-j:i]==t[0:j]，而且t[j]结尾的长度为k（即suffix[j]）的子串恰好是t的前缀，所以我们立即得知s[i-k+1:i]（即以s[i]为结尾的长度为k的子串）与t[0:k-1]（即t的长度为k的前缀串）已经是匹配的了。

====================

接下来我们正式研究如何求这个后缀数组suffix。

我们令dp[i]表示该字符串最长的前缀字符串，使得其恰等于截止i位置的后缀字符串。即如果```dp[i]=k```,那么```s[0:k-1] = s[i-k+1:i]```.

我们利用一下动态规划的思想，看看dp[i]能否从dp[i-1]的信息推演过来？我们令j=dp[i-1]，即查看截止i-1位置的最长后缀字符串，用星号表示（长度为j）：
```
* * * * * * * * * * * * * * * * *   X  ________________________________  * * * * * * * * * * * * * * * * *   Y
                               j-1, j                                                                   i-1, i
```
如果在s[j]和s[j]这两处的字符相同（即X==Y），那么显然我们就说明dp[i]可以在之前长度j的后缀字符串上再延长一位，即dp[i] = j+1.

如果在s[j]和s[j]这两处的字符相同不相同（即X!=Y），我们该如何寻找截止i位置的最长后缀字符串呢？我们把目光放到s[0:j-1]这段区间上来。我们类似的其实也有dp[j-1]，这段长度表示截止j-1位置时的最长后缀字符串，我们画出来看看：
```
+ + + + + Z ____________ + + + + +  X  ________________________________  _______________________ + + + + +   Y
       j'-1                    j-1, j                                                                   i-1, i
```                               
我们令```j' = dp[j-1]```，那么有```s[0:j'-1] = s[j-j':j-1]```，同时我们这两段区间必然也和s[i-j':i-1]相同！此时我们就又有了希望，如果s[j']和s[i]这两处的字符相同（即Z==Y），那么我们就又有了一段截止i位置时的最长字符串（长度为j'）。

当然，也有可能Z和Y匹配不成功，那么我们可以同理再考察截止j'-1位置的最长后缀字符串，它的长度应该是```j'' = dp[j'-1]```，然后再尝试考察s[j'']是否与s[i]相同...

所以我们发现一个规律：对于dp[i]，我们先看长度为j=dp[i-1]的前缀字符串，是否能有s[j]==s[i]。不行，就再看长度为j'=dp[j'-1]的前缀字符串，是否能有s[j']==s[i]。不行就再看长度为j''=dp[j''-1]的前缀字符串，是否能有s[j'']==s[i]...直至最终停下来，得到一个最终可利用的前缀长度j，那么```dp[i] = j + (s[i]==s[j])```

总结一下：
```cpp
for (int i=1; i<n; i++)
{
    // compute dp[i]
    int j = dp[i-1];
    while (j>0 && s[j]!=s[i])
       j = dp[j-1];
    dp[i] = j+(s[j]==s[i]);   
}    
```
特别注意dp[0]=0（因为我们求的是最长“真前缀”），所以循环从index为1的元素开始。
