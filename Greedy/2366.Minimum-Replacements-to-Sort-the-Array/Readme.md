### 2366.Minimum-Replacements-to-Sort-the-Array

我们从后往前看，对于最后一个数，我们肯定不会拆分。一旦将其拆分的话变小的话，那么前面的数就有更大的概率需要拆得更小。

接着假设最后一个数是x，倒数第二个数是y。如果y小于等于x，那么最后两个元素已经是递增关系，y就不用拆分了，理由同上。如果y大于x，那么就必须拆分y，那么怎么拆分呢？

根据规则，我们想要尽量少地拆分，又不能拆出大于x的数（否则破坏递增），不难通过贪心的思想，知道我们需要尽量拆出x来。假设y除以x的商是k，余数是d，那么我们有一个初始方案：就是拆成一个d，加上k个x。这一定保证了拆分数最少。但是d太小的话，会影响左侧元素迫使他们拆分地更细。所以我们试图在不改变这k+1份的前提下，尽量地抬升d。怎么抬升呢？显然是由这k个x来提供帮助。如果这k个x集体减少一，那么d就能抬升k。为什么这k个x需要集体行动呢？因为人多力量大啊，让某些x不出力的话留着也没有啥用，不如提供给d来加速d的抬升。

那么我们将d抬升多少呢？注意提升后的d不能比下降后的x高。因为我们想抬升d是因为d是当前y拆分出来的最小值，是制约前面元素拆分的“瓶颈”。所以最理想的情况是y恰好拆分成均匀的k份。
