### 2193.Minimum-Number-of-Moves-to-Make-Palindrome

这道题存在着一个非常直观的贪心策略，我们从左往右遍历每个字符s[i]，找到与它能够组成回文对称的那个s[j]，那么将其从j移动到与s[i]回文对称的位置（在总长度是偶数的条件下就是n-1-i）即可。如果暴力地用swap来模拟这个过程，那么就是o(N^2)的复杂度：遍历i是o(N)，对于每个i，用o(N)找到j，并且将j移动到n-1-i。

那么这个贪心策略如何证明呢？也就是说，如果当前字符串最左边是x，那么为什么我们贪心地就把一对x调整到最外层，而不是把其他的一对y调整到最外层呢？我们不失一般性地描述出x和y可能的位置位置关系：
1. ```x ... y... y ... x .....``` 很明显，我们必然先搬动这对x到外侧，再搬动这对y到x的内侧
2. ```x ..(a).. y..(b).. x ..(c).. y ..(d)..``` 我们用abcde表示每段区间的长度。    
    (1) 策略1是将x搬动到外侧，那么需要 0 + (c+d+1)，再搬动y到x的内侧，需要(a) + (d)    
    (2) 策略2是将y搬动到外侧，那么需要 (a+1) + (d)，再搬动x到y的内侧，需要 0 + (c+d)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+d+1
3. ```x ..(a).. x..(b).. y ..(c).. y ..(d)..``` 
    (1) 策略1是将x搬动到外侧，那么需要 (0) + (b+c+d+2)，再搬动y到x的内侧，需要 (a+b+1) + (d)
    (2) 策略2是将y搬动到外侧，那么需要 (a+b+2) + (d)，再搬动x到y的内侧，需要(0) + (b+c+d+1)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+b+c+3
    
所以我们得出结论，无论什么情况下，我们只需要把最左边的x固定，将另一个对称的x放到左右边，就是当前的最佳策略。处理完之后就可以剥除最外面一对，递归处理剩下的字符串即可。

OK，以上我们只是考虑了总长度是偶数的情况。如果回文串长度是奇数，那么这个需要放在中心位置的字符，一定是唯一频次是奇数的字符里最靠中间那个，这个是不难找出来的。那么我们要对其做什么处理呢？注意，我们在调整配对完其他字符前，不应该调整它的位置。
