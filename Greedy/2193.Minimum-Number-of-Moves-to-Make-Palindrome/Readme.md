### 2193.Minimum-Number-of-Moves-to-Make-Palindrome

#### 解法1：贪心加暴力模拟
这道题存在着一个非常直观的贪心策略，我们从左往右遍历每个字符s[i]，找到与它能够组成回文对称的那个s[j]，那么将其从j移动到与s[i]回文对称的位置（在总长度是偶数的条件下就是n-1-i）即可。如果暴力地用swap来模拟这个过程，那么就是o(N^2)的复杂度：遍历i是o(N)，对于每个i，用o(N)找到j，并且将j移动到n-1-i。

那么这个贪心策略如何证明呢？也就是说，如果当前字符串最左边是x，那么为什么我们贪心地就把一对x调整到最外层，而不是把其他的一对y调整到最外层呢？我们不失一般性地描述出x和y可能的位置位置关系：
1. ```x ... y... y ... x .....``` 很明显，我们必然先搬动这对x到外侧，再搬动这对y到x的内侧
2. ```x ..(a).. y..(b).. x ..(c).. y ..(d)..``` 我们用abcde表示每段区间的长度。    
    (1) 策略1是将x搬动到外侧，那么需要 0 + (c+d+1)，再搬动y到x的内侧，需要(a) + (d)    
    (2) 策略2是将y搬动到外侧，那么需要 (a+1) + (d)，再搬动x到y的内侧，需要 0 + (c+d)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+d+1
3. ```x ..(a).. x..(b).. y ..(c).. y ..(d)..``` 
    (1) 策略1是将x搬动到外侧，那么需要 (0) + (b+c+d+2)，再搬动y到x的内侧，需要 (a+b+1) + (d)
    (2) 策略2是将y搬动到外侧，那么需要 (a+b+2) + (d)，再搬动x到y的内侧，需要(0) + (b+c+d+1)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+b+c+3
    
所以我们得出结论，无论什么情况下，我们只需要把最左边的x固定，将另一个对称的x放到左右边，就是当前的最佳策略。处理完之后就可以剥除最外面一对，递归处理剩下的字符串即可。

OK，以上我们只是考虑了总长度是偶数的情况。如果回文串长度是奇数，那么在上述“递归处理”的过程中，我们会遇到这样一种情况：此时字符串的最左边是一个仅出现一次的字符（记做w）。那么我们要对w做什么处理呢？答案是我们应该直接忽略掉它，先处理下一个。也就是说，只有在处理完剩下的所有配对之后，再去考察w需要位移几次（就是n/2与w所在index之差）。比如说waabb，正解是忽略w，先调整得到wabba，再将w插入abba的中央，总的交换次数是4. 如果我们试图先将w放入中央得到aawbb，那么再使得aabb对称的话，总的交换次数就需要2+3。

#### 解法2：贪心加统计逆序对
上面的贪心解法配合的是暴力移动。事实上我们有“虚拟移动”的方法来提高效率。

根据前面的分析，最优的做法其实分三步：1. 将所有配对字符的左半边，按照其出场顺序移动到字符串的左侧。2. 如果总长度是奇数，那么将落单的字符移动到n/2的位置。3. 此时剩余的字符（即所有配对字符的右半边）仍然是按照出场顺序排列的，但是都已经挪到了字符串的右侧，此时我们只需要将这个乱序的substring进行操作，使得顺序变得和左侧（更确切地说是与左侧的倒序）一致即可。

举个例子，假设在第1步里第一个遇到的是字符a，与之配对的另一个a的位置是7；第二个遇到的是字符b，与之配对的另一个b的位置是5；第三个遇到的是字符c，与之配对的另一个c的位置是9. 那么说明在原始串579这些位置的字符，我们希望通过adjacent swap的操作最终变为957的顺序。因为最右侧的7对应着与a配对，中间的5对应着与b配对，左边的9对应着与c配对。

那么需要多少次adjacent swap使得579变成957呢？这个问题等价于将一个乱序957变成顺序579. 这是一个经典题，答案是统计所有逆序对的个数。在这里(9,5)和(9,7)是逆序对（即前者大于后者），所以我们只需要两次交换就可以将957->579. 而求逆序对，就是LC.493的原题。
