### 313.Super-Ugly-Number

#### 解法1
仿效find the n-th largest element from k sorted lists. 从1开始，每次从优先队列里弹出当前最小的数，然后分别乘以k个质数再放入队列中。直至弹出n个数为止。

注意到装入队列的元素可能会是重复的。所以此处用set更方便。

#### 解法2：
仿效```264	Ugly Number II```，每一个回合，下一个最小的丑数nxt，必然是某个老丑数乘以某个质数。现在有k个质数，说明nxt的候选者其实有k个，分别对应着k个老丑数分别乘以k个质数。所以我们给每个质数prime[j]分配一个指针p[j]指老丑数的位置，这个指针在整个过程中必然是要顺次移动。假设当前nxt的所有候选者中，```prime[j]*prime[p[j]]```最小而胜出，那么这个质数的指针以后就要右移一位，即```p[j]++```；其他质数的指针不变。

注意到丑数序列的第一个是1，我们重复n-1遍上述的过程，就可以得到答案（第n个丑数）。
