### 2896.Apply-Operations-to-Make-Two-Strings-Equal

注意到，如果从i开始的、将连续k对相邻的两个元素flip（每次代价为1），本质上就是将i和i+k距离k的两个元素flip，代价就是k。

所以，我们直接将s1和s2里面元素不同的index拿出来放在nums数组里。于是任务就是：每次在nums里挑两个（未访问过的）元素，代价是|nums[j]-nums[i]|或者x。问最少花多少代价能将nums全部访问。

对于这个问题，首先要明确并没有任何贪心的方法。每次如何挑选两个元素，并没有特定的规律，最优解会随着数据的不同有各种不同的表现。我们只能用DP或者搜索的方式来解。

### 解法1:o(n^3)
最容易想到的是一个o(N^3)的区间DP。我们想得到区间的最优解dp[i][j]，只有两种拆解的方式：
1. 遍历一个中间的分界点k，我们先将[i:k]处理完，再将[k+1:j]处理完，那么dp[i][j]就是这两部分最优代价的和。
2. 最后一个访问的pair是(i,j)，所以dp[i][j] = dp[i+1][j-1] + cost(i,j).

最终取最优的解作为dp[i][j]. 大致的代价如下
```cpp
for (int d = 1; d<=n; d++) {
    for (int i=0; i+d-1<n; i++) {
        int j = i+d-1;
        dp[i][j] = dp[i+1][j-1] + cost(i,j);
        for (int k=i+1; k+1<j; k++) {
            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]);
        }
    }
}
return dp[0][n-1];
```

### 解法2:o(n^2)
