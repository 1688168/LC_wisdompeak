### 664.Strange-Printer

我们查看这样一个例子：
```
a X X X X a X X a X X X a  X X X
i         x     y       z     j
```
首先，第一个字符'a'是必须主动打印的。此外，不难想到如果我们在打印第一个'a'的时候，把打印区间往右扩展一些以覆盖到后续的'a'，就有可能为省下一些打印后面的'a'的操作。那么我们可以扩展到哪里呢？显然在上面的例子里，我们只需要考虑三种选择，将'a'从首元素i打印到位置x、或y、或z，因为这三个位置上的字符也都是'a'。容易知道，如果把区间的右端点落在其他位置上，都是没有意义的（总是会被其他字符覆盖掉）。

所以，我们对于打印区间[i:j]的最优策略就是在下面的两方案中选择最优的：
```cpp
dp[i][j] = 1+dp[i+1][j];  // 只打印一个首字符
dp[i][j] = min { dp[i][k-1] + dp[k+1][j] }  for all k s.t. s[k]==s[i]  // 打印一串首字符从i到k
```
有人对第二行产生疑惑：“打印区间”这一步操作为什么没有体现，即转移方程为什么不是```dp[i][j] = 1 + dp[i+1][k-1] + dp[k+1][j]```？

这是一个很深刻的问题。在此有两点说明：
1. ```dp[i][k-1]```肯定包括了```1 + dp[i+1][k-1]```，后者只是前者的一部分。
2. ```dp[i][k-1]```蕴含着一个重要的信息，就是我们处理区间[i:k-1]时，依然必须先打印首元素、或者以首元素开头的一个区间。而```dp[i+1][k-1]```则丢失了关于打印s[i]的信息。我们回看上面的那个例子，假设k取在y这个位置。那么我们眼中的```dp[i][y-1]```可以包含这么一种可能：s[i]和s[x]都是同一批次打印出来的。但是如果写成```1+dp[i+1][y-1]```，那么以dp[i+1][y-1]的眼光来看，s[x]必须单独消耗一次操作打印出来，因为它已经割裂了与s[i]的关系。

综上，因为是典型的区间型DP，我们需要从小区间推导出大区间，所以两层循环的模板如下：
```cpp
          for (int len=2; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                dp[i][j] = 1+dp[i+1][j];
                
                for (int k=i+1; k<=j; k++)
                {
                    if (s[k]==s[i])                    
                        dp[i][j] = min(dp[i][j], dp[i][k-1] + ((k+1>j)?0:dp[k+1][j]));
                }                    
            }      
```
初始条件是：
1. dp[i][j]==1 when i==j，即len的长度为1; 
2. dp[i][j]==0 when i>j. 注意这个是允许遇到的，比如上面的例子，如果区间[i:j]里面的s[j]==s[i]，于是k可以取到j，转移方程的dp[k+1][j]就会出现这种情况。


[Leetcode Link](https://leetcode.com/problems/strange-printer)
