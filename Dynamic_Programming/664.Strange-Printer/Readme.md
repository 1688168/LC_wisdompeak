### 664.Strange-Printer

我们查看这样一个例子：
```
a X X X X a X X a X X X a  X X X
i         x     y       z     j
```
第一个字符'a'是必须主动打印的。此外，如果我们在打印第一个'a'的时候，把打印区间扩大一些以覆盖到后续的a，就有可能省下后面的'a'的打印操作。那么能“多”打多少呢？显然在上面的例子里，我们只需要考虑三种选择，将连续的'a'从i打到位置x或y或z，这三个位置上的字符也都是'a'。容易判断，连续'a'的右端点如果落在其他位置上，都是没有意义的。

所以，我们对于区间[i:j]的打印策略：0. 基础方案是```dp[i][j] = 1+dp[i+1][j]```. 1.找到一处位置k满足s[i]==s[k]，2. 将[i:k]都打印成s[i]，3. 我们有```dp[i][j] = dp[i][k-1]+dp[k+1][j]```. 4. 最后，对于所有的k（以及没不考虑k），我们取其中最小的dp[i][j]。

有人会问疑惑转移方程为什么不是```dp[i][j] = 1 + dp[i+1][k-1]+dp[k+1][j]```. 




顺便把整个字符串都打印上a，那么字符串中间的那个a就占了便宜。我们接下来只需要考虑处理两个更小的区间```X X X X```怎么打印就行了。也就是说，此时动态转移方程呼之欲出： 

设计动态转移方程dp[i][j]，表示打印以s[i]开始、s[j]结尾的子串，需要最少的turns。
```cpp
dp[i][j] = 1+dp[i+1][j]  //基本款
dp[i][j] = min { dp[i][k-1] + dp[k+1][j] }  for s[k]==s[i]
```
注意，如果k+1>j，那么dp[k+1][j]的值默认为0.

如果你有兴趣，会更深入地想，在处理dp[i][j]的时候，为什么首先一定是先从i位置开始打印一串s[i]的字符呢？为什么不是先打印其他地方的字符，再从i位置开始打印一串s[i]的字符呢？原因是s[i]不能依靠打印其他字符时被“捎带”上，必须老老实实在i的位置单独打印。与其在i位置单独打一个s[i]，肯定不如顺便直接打出一串s[i]。想到这点的话，如果我们先打印了其他地方的XXXX的字符、再不幸被这串s[i]覆盖的话，显然效率肯定低，不如索性第一步就从i位置开始打印一串s[i]的字符。这就是以上思想为什么总是我们在处理dp[i][j]时，总是考虑首先要打印一串s[i]的原因。

因为根据dp[i][j]的定义，显然是从小区间推导出大区间的过程，所以两层循环的模板如下：
```cpp
          for (int len=2; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                dp[i][j] = 1+dp[i+1][j];
                
                for (int k=i+1; k<=j; k++)
                {
                    if (s[k]==s[i])                    
                        dp[i][j] = min(dp[i][j], dp[i][k-1] + ((k+1>j)?0:dp[k+1][j]));
                }                    
            }      
```
初始条件是：
1. dp[i][j]==1 when i==j，即len的长度为1; 
2. dp[i][j]==0 when i>j; C语言里如果用int[][]来定义二维数组的话，元素默认值都是0.


[Leetcode Link](https://leetcode.com/problems/strange-printer)
