### 1644.Lowest-Common-Ancestor-of-a-Binary-Tree-II

此题与LC.236相比，区别在于我们必须判定p和q的存在。因为236里面递归函数的返回值定义的是：或者p，或者q，或者p与q的LCA。因此假如q并不存在的话，递归函数依然能有非空的返回值，但返回的仅仅是p而已。

这就要求我们的递归函数必须强制把所有的节点都遍历完，并且确认访问过p和q。怎么办呢？复盘LC.236的代码里，我们有提前返回的逻辑
```cpp
if (root==p || root==q) return root;
```
正是因为这行代码如果发生在递归左右节点之前，那么我们没有机会遍历所有的节点。

所以我们应该把这一段代码移到递归左右节点之后。这样我们就一定会访问到所有的节点。同时我们还需要再加一行代码来判定是否遇到过p和q就行。只有p和q都访问过的flag为true时，整体递归函数返回的节点才是真正的LCA。
