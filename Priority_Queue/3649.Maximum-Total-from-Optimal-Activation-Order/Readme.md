### 3649.Maximum-Total-from-Optimal-Activation-Order

基本的思路是反悔贪心。

我们将所有元素按照limit从小到大排序（limit相同的情况下，value更大的优先），因为limit小的必须先挑，否则当active_number很大的时候就无法再取了。排序之后逐个考察每个元素：
1. 如果`L>active_number`，那么就可以无脑选取该元素的value。
2. 反之，意味着我们无法再新加这个元素，但是我们依然有机会更新ret，那就是将已经选取的元素里踢掉最小的一个，替换成当前的这个元素（如果更优的话）。这样的操作是合法的，因为被替换的元素的L更小，在它被选中的那个回合我们“回溯地”为这个L更大的元素是符合规则的。

以上就是本题的基本贪心规则。除此之外，题目还有一个规则，就是active_number其实是可以减少的。所以我们需要用一个Hash表，记录每种limit的元素已经有多少被选中了（即active的状态）。当我们的active_number增长到某个数值A的时候，需要再减去Map[A]，同时将Map[A]清零，并且以后再次遇到limit是A的元素都直接跳过。

