### 1851.Minimum-Interval-to-Include-Each-Query

对于offline querying的问题，我们首先想到是否可以调整query的顺序来使得问题简化。

对于一个query的时刻q，我们要找到所有区间包括q的events。为了每一个q而filter一遍events是低效的，使得时间复杂度达到了O(QN). 我们的目标是随着q的遍历，只需对考察的events集合进行增补（引进新的、舍弃旧的），使得events的总遍历是线性时间。

我们想象，对于时刻q，符合题意的events肯定要求始时刻必须早于q，但是我们又必须把结束时刻早于q的时间排除掉。这就给了我们基本的灵感。我们将所有起始时刻早于q的事件放入一个events pool，但是这个pool又是按照结束时刻排序的（比如优先队列），这样我们就可以通过查看优先队列的队首元素，来弹出结束时刻不符合要求的事件。我们又想到，如果以后的query时刻都比q还晚的话，这些已经被弹出的events肯定以后也再不会被用到。所以这就提示了我们需要对于离线查询的预处理：将所有的query按照时间排序。

OK，优先队列经过调整之后，里面的events都满足了起始/结束时刻的跨度包含q，那么我们如何找到其中duration最短的那个呢？我们需要另外维护一个有序Set，这个Set里面events的更新是随着优先队列的更新完全同步的（即放入和弹出events），但是Set本身是按照duration排序的，这样我们就很容易读取Set.begin()知道当前events pool里的最短duration。

本题的时间复杂度是o(NlogN)，其中N是事件的个数。因为每个event只会进入pool一次，出pool一次，每次插入/弹出都是logN的时间。这与query的数量没有关系。
